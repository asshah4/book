[
["index.html", "Thoughts Preface", " Thoughts Anish Shah 2020-05-28 Preface This initially was designed to help document exploratory concepts that were developed using the card package, but also expanded to clinical concepts leveraging the power of R and Rmarkdown. As this develops, it will likely create its own order. Currently it revolves around the principal components: circadian rhythm electrocardiography autonomic physiology clinical medicine "],
["this-project-is-built-with-several-libraries-from-cran.html", "0.1 This project is built with several libraries from CRAN", " 0.1 This project is built with several libraries from CRAN bookdown pkgdown "],
["circadian.html", "Chapter 1 Circadian Physiology ", " Chapter 1 Circadian Physiology "],
["chronobiology.html", "1.1 Chronobiology", " 1.1 Chronobiology Will discuss circadian biology/physiology. "],
["circadian-disruption.html", "1.2 Circadian Disruption", " 1.2 Circadian Disruption "],
["cosinor.html", "Chapter 2 Cosinor Analysis", " Chapter 2 Cosinor Analysis The issue with time series analysis is that the data is by its nature circular and thus cannot be easily be analyzed through traditional, linear methods. The following is the development/expansion of the cosinor model to help study circadian rhythms (1). "],
["overview.html", "2.1 Overview", " 2.1 Overview The card package was developed to help tackle this problem. # Library library(card) library(ggplot2) # Dataset data(&quot;twins&quot;) # Example of data ggplot(twins, aes(x = hour, y = rDYX)) + geom_smooth(method = &quot;gam&quot;, se = TRUE) ## `geom_smooth()` using formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; Using the cosinor() function, the characteristics of the circadian pattern can be retrieved. # Cosinor model m &lt;- cosinor(rDYX ~ hour, twins) summary(m) ## Call: ## cosinor(&quot;rDYX ~ hour&quot;) ## ## Residuals: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -3.12633 -0.53228 -0.03597 0.00000 0.49132 4.82150 ## ## Coefficients: ## mesor amp phi beta gamma ## 2.8604855 0.2986101 -2.6687044 -0.2658396 0.1360048 The statistical principles behind this method allow for different methods to model, diagnose, and interpret findings. (Refinetti, Cornélissen, and Halberg 2007; Cornelissen 2014) single component cosinor multiple component cosinor population cosinor zero amplitude test lack-of-fit testing confidence intervals (ellipse method) References "],
["single-component-cosinor.html", "2.2 Single component cosinor", " 2.2 Single component cosinor The single component cosinor method is modeled as: \\[Y(t) = M + A cos(2 \\pi t / period) + \\epsilon\\] "],
["population-mean-cosinor.html", "2.3 Population-mean cosinor", " 2.3 Population-mean cosinor Based on the work by Cornelissen et al 2014 (Cornelissen 2014), the population mean cosinor can be estimated by applying the single or multiple component cosinor to each individual. Each parameter can then be “averaged” to estimate the population parameters. \\[\\{\\hat{u} = \\hat{M}_{i} + \\hat\\beta_{i} + \\hat\\gamma_{i} + ... \\}\\] Where \\(i = 1, 2, ..., k\\) for each individual contribution to the population cosinor metrics. # Parameters for population mean cosinor df &lt;- twins[1:105, c(&quot;rDYX&quot;, &quot;hour&quot;, &quot;patid&quot;)] names(df) &lt;- c(&quot;y&quot;, &quot;t&quot;, &quot;pop&quot;) # Number of individuals k &lt;- length(unique(df$pop)) # Individual cosinor models are implemented for each individual kCosinors &lt;- with( df, by(df, pop, function(x) { cosinor(y ~ t, data = x, tau = 24) }) ) ## [1] &quot;Confidence regions overlap the poles. Confidence intervals for amplitude and acrophase cannot be determined.&quot; ## [1] &quot;Confidence regions overlap the poles. Confidence intervals for amplitude and acrophase cannot be determined.&quot; ## [1] &quot;Confidence regions overlap the poles. Confidence intervals for amplitude and acrophase cannot be determined.&quot; ## [1] &quot;Confidence regions overlap the poles. Confidence intervals for amplitude and acrophase cannot be determined.&quot; # The coefficients have to be extracted and summarized tbl &lt;- sapply(kCosinors, stats::coef) coef_names &lt;- c(&quot;mesor&quot;, &quot;amp&quot;, &quot;phi&quot;, &quot;beta&quot;, &quot;gamma&quot;) rownames(tbl) &lt;- coef_names xmat &lt;- t(tbl) # Get mean for each parameter (mesor, beta, gamma), ignoring averaged amp/phi coefs &lt;- apply(xmat, MARGIN = 2, function(x) { sum(x) / k }) mesor &lt;- unname(coefs[&quot;mesor&quot;]) beta &lt;- unname(coefs[&quot;beta&quot;]) gamma &lt;- unname(coefs[&quot;gamma&quot;]) # Get amplitude amp &lt;- sqrt(beta^2 + gamma^2) # Acrophase (phi) must be in correct quadrant sb &lt;- sign(beta) sg &lt;- sign(gamma) theta &lt;- atan(abs(gamma / beta)) if ((sb == 1 | sb == 0) &amp; sg == 1) { phi &lt;- -theta } else if (sb == -1 &amp; (sg == 1 | sg == 0)) { phi &lt;- theta - pi } else if ((sb == -1 | sb == 0) &amp; sg == -1) { phi &lt;- -theta - pi } else if (sb == 1 &amp; (sg == -1 | sg == 0)) { phi &lt;- theta - (2 * pi) } # Update coefficients coefs[&quot;amp&quot;] &lt;- amp coefs[&quot;phi&quot;] &lt;- phi # Updated coefficients names(coefs) &lt;- coef_names print(coefs) ## mesor amp phi beta gamma ## 2.73343430 0.13693035 -1.72263447 -0.02071145 0.13535493 "]
]
